#include "flex_pimpl_plugin/CodeGenerator.hpp" // IWYU pragma: associated

#include <flexlib/reflect/ReflTypes.hpp>
#include <flexlib/reflect/ReflectAST.hpp>
#include <flexlib/reflect/ReflectionCache.hpp>
#include <flexlib/ToolPlugin.hpp>
#include <flexlib/core/errors/errors.hpp>
#include <flexlib/utils.hpp>
#include <flexlib/funcParser.hpp>
#include <flexlib/inputThread.hpp>
#include <flexlib/clangUtils.hpp>
#include <flexlib/clangPipeline.hpp>
#include <flexlib/annotation_parser.hpp>
#include <flexlib/annotation_match_handler.hpp>
#include <flexlib/matchers/annotation_matcher.hpp>
#include <flexlib/options/ctp/options.hpp>
#if defined(CLING_IS_ON)
#include "flexlib/ClingInterpreterModule.hpp"
#endif // CLING_IS_ON

#include <clang/Rewrite/Core/Rewriter.h>
#include <clang/ASTMatchers/ASTMatchFinder.h>
#include <clang/AST/RecursiveASTVisitor.h>
#include <clang/AST/ASTContext.h>
#include <clang/Lex/Preprocessor.h>

#include <base/cpu.h>
#include <base/bind.h>
#include <base/command_line.h>
#include <base/debug/alias.h>
#include <base/debug/stack_trace.h>
#include <base/memory/ptr_util.h>
#include <base/sequenced_task_runner.h>
#include <base/strings/string_util.h>
#include <base/trace_event/trace_event.h>
#include <base/logging.h>
#include <base/files/file_util.h>

#include <any>
#include <string>
#include <vector>
#include <regex>
#include <iostream>
#include <fstream>

namespace plugin {

/// \todo move to flexlib, remove code duplication in multiple plugins
std::string expandTemplateNames(
  const std::vector<reflection::TemplateParamInfo>& params)
{
  std::string out;
  size_t paramIter = 0;
  const size_t methodParamsSize = params.size();
  for(const auto& param: params) {
    out += param.tplDeclName;
    paramIter++;
    if(paramIter != methodParamsSize) {
      out += clang_utils::kSeparatorCommaAndWhitespace;
    } // paramIter != methodParamsSize
  } // params endfor
  return out;
}

std::string methodParamDecls(
  const std::vector<reflection::MethodParamInfo>& params)
{
  std::string out;
  size_t paramIter = 0;
  const size_t methodParamsSize = params.size();
  for(const auto& param: params) {
    out += param.fullDecl;
    paramIter++;
    if(paramIter != methodParamsSize) {
      out += clang_utils::kSeparatorCommaAndWhitespace;
    } // paramIter != methodParamsSize
  } // params endfor
  return out;
}

bool isPimplMethod(
  const reflection::MethodInfoPtr& methodInfo)
{
  // only normal member functions should have
  // wrappers generated for them
  return
    /**
     * isImplicit - Indicates whether the declaration
     * was implicitly generated by the implementation.
     * https://clang.llvm.org/doxygen/classclang_1_1Decl.html
     **/
      !methodInfo->isImplicit
    /**
     * logic to detect |isOperator|:
         bool isOperator
           = decl->isOverloadedOperator()
             || (!decl->hasUserDeclaredCopyAssignment()
               && decl->hasCopyAssignmentWithConstParam())
             || (!decl->hasUserDeclaredMoveConstructor()
               && decl->hasMoveAssignment())
     **/
      && !methodInfo->isOperator
      && !methodInfo->isCtor
      && !methodInfo->isDtor;
}

pimplCodeGenerator::pimplCodeGenerator()
{
  DETACH_FROM_SEQUENCE(sequence_checker_);
}

pimplCodeGenerator::~pimplCodeGenerator()
{
  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
}

} // namespace plugin
